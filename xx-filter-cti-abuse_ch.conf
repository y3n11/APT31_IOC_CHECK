input {
    beats {
        port => 5044
        type => 'beats'
    }
}


filter {

    if [destination][ip] {

        translate {
        
            field => '[destination][ip]'
            destination => '[temp_dst_ip_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/ipblocklist.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_dst_ip_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('destination.ip')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }

        mutate {

            remove_field => [ "[temp_dst_ip_check]" ]
        }
    }

    if [source][ip] {

        translate {
        
            field => '[source][ip]'
            destination => '[temp_src_ip_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/ipblocklist.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_src_ip_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('source.ip')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_src_ip_check]" ]
        }
    }

    if [file][hash][md5] {

        translate {
        
            field => '[file][hash][md5]'
            destination => '[temp_file_hash_md5_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_md5.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_file_hash_md5_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('file.hash.md5')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_file_hash_md5_check]" ]
        }
    }

    if [file][hash][sha1] {

        translate {
        
            field => '[file][hash][sha1]'
            destination => '[temp_file_hash_sha1_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_sha1.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_file_hash_sha1_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('file.hash.sha1')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_file_hash_sha1_check]" ]
        }
    }


    if [file][hash][sha256] {

        translate {
        
            field => '[file][hash][sha256]'
            destination => '[temp_file_hash_sha256_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_sha256.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_file_hash_sha256_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('file.hash.sha256')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }

        }
        
        mutate {

            remove_field => [ "[temp_file_hash_sha256_check]" ]

        }
    }

    if [process][hash][md5] {

        translate {
        
            field => '[process][hash][md5]'
            destination => '[temp_process_hash_md5_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_md5.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_process_hash_md5_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('process.hash.md5')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }

        }
        
        mutate {

            remove_field => [ "[temp_process_hash_md5_check]" ]
        }
    }

    if [process][hash][sha1] {

        translate {
        
            field => '[process][hash][sha1]'
            destination => '[temp_process_hash_sha1_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_sha1.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_process_hash_sha1_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('process.hash.sha1')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }

        mutate {

            remove_field => [ "[temp_process_hash_sha1_check]" ]
        }
    }

    if [process][hash][sha256] {

        translate {
        
            field => '[process][hash][sha256]'
            destination => '[temp_process_hash_sha256_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_sha256.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_process_hash_sha256_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('process.hash.sha256')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_process_hash_sha256_check]" ]
        }
    }



    if [dll][hash][md5] {

        translate {
        
            field => '[dll][hash][md5]'
            destination => '[temp_dll_hash_md5_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_md5.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_dll_hash_md5_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('dll.hash.md5')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_dll_hash_md5_check]" ]
        }

    }

    if [dll][hash][sha1] {

        translate {
        
            field => '[dll][hash][sha1]'
            destination => '[temp_dll_hash_sha1_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_sha1.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_dll_hash_sha1_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('dll.hash.sha1')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }

        mutate {

            remove_field => [ "[temp_dll_hash_sha1_check]" ]
        }
    }

    if [dll][hash][sha256] {

        translate {
        
            field => '[dll][hash][sha256]'
            destination => '[temp_dll_hash_sha256_check]'
            dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/bazaar_sha256.json'
            override => 'true'
            fallback => 'False'
        }

        if [temp_dll_hash_sha256_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('dll.hash.sha256')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_dll_hash_sha256_check]" ]
        }
    }

    if [url][full] {

    	translate {

    		field => '[url][full]'
    		destination => '[temp_url_full_check]'
    		dictionary_path => '/etc/logstash/conf.d/dictionaries/abuse_ch/urlhaus_recent.json'
    		override => 'true'
    		fallback => 'False'
    	}

        if [temp_url_full_check] == 'True' {
        
            mutate {

                add_field => { '[threat][ioc][check]' => 'True' }

            }

            ruby {
                code => "

                    if event.get('[threat][ioc][type]')

                        ioc_types = event.get('[threat][ioc][type]')

                    else

                        ioc_types = []

                    end

                    ioc_types.push('url.full')
                    event.set('[threat][ioc][type]', ioc_types)

                "
            }
        }
        
        mutate {

            remove_field => [ "[temp_url_full_check]" ]
        }
    }

}


output {

        elasticsearch {

                ssl => true
                ssl_certificate_verification => true
                cacert => '/etc/logstash/elastic-ca.pem'
                hosts => ["https://172.31.23.143:9200"]
                user => "elastic"
                password => "hD6iTkozfHURrQ2LJBOe"
                index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"

        }

        stdout { codec => rubydebug }

}
